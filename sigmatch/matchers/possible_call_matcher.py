from typing import Any, Callable

from sigmatch import FunctionSignatureMatcher
from sigmatch.errors import SignatureMismatchError
from sigmatch.matchers.abstract import AbstractSignatureMatcher


class PossibleCallMatcher(AbstractSignatureMatcher):
    def _match(self, function: Callable[..., Any], raise_exception: bool = False) -> bool:
        """
        1. Если способ вызова содержит *:
        1.1. В сигнатуре функции тоже должна быть *, иначе не валидно
        1.2. Если сигнатура содержит * И точки, значит количество точек в способе вызова должно быть не меньше числа точек в сигнатуре.
        Иначе возможна ситуация, что вызов не заполнит все слоты в сигнатуре. Для ошибок этого типа нужно отдельное сообщение об ошибке.

        2. Если в способе вызова нет *:
        2.1. Если в сигнатуре есть *: количество точек способа вызова должно быть БОЛЬШЕ ИЛИ равно количеству точек в сигнатуре
        2.2. Если в сигнатуре нет *: количество точек способа вызова должно быть равно количеству точек в сигнатуре

        3. Если способ вызова содержит **:
        3.1. Сигнатура должна содержать **
        3.2.1 Если в способе вызова есть именные аргументы, в сигнатуре НЕ должно быть других обязательных именных параметров, кроме перечисленных в способе вызова
        3.2.2. Если в способе вызова нет именных аргументов, сигнатура не должна содержать никаких обязательных именных аргументов
        (обобщается с 3.2.1 как: любые обязательные именные аргументы сигнатуры должны содержаться в множестве тех, что перечислены в способе вызова)

        4. Если в способе вызова нет **:
        4.1. Если сигнатура не содержит **, именные аргументы сигнатуры и способа вызова должны строго совпадать (не больше и не меньше)
        4.2. Если сигнатура содержит **, в ней не должно быть других обязательных аргументов кроме x и y
        """
        callable_matcher = FunctionSignatureMatcher(*self._get_symbols_from_callable(function))

        result = True

        if self.is_args:
            if not callable_matcher.is_args:
                result = False
            if callable_matcher.number_of_position_args and (self.number_of_position_args < callable_matcher.number_of_position_args):
                if raise_exception:
                    raise SignatureMismatchError
                result = False
        elif callable_matcher.is_args:
            if self.number_of_position_args < callable_matcher.number_of_position_args:
                result = False
        elif self.number_of_position_args != callable_matcher.number_of_position_args:
            result = False

        if self.is_kwargs and not callable_matcher.is_kwargs:
            result = False

        elif self.is_kwargs or callable_matcher.is_kwargs:
            call_arguments = set(self.names_of_named_args)
            for argument_name in callable_matcher.names_of_named_args:
                if argument_name not in call_arguments:
                    result = False
                    break

        elif set(self.names_of_named_args) != set(callable_matcher.names_of_named_args):
            result = False

        return result


"""
# Как мэтчить способ вызова с сигнатурой конкретной функции?

1. Чекаем неименные аргументы
2. Чекаем именные аргументы

# Позиционные аргументы

Дан способ вызова:

.. *

Что это значит? Количество позиционных аргументов, которые будут переданы в функцию, будет любым, но не меньше 2

Другой способ вызова:

*

Что это значит? Любое количество позиционных аргументов может быть передано

Третий вариант:

..

Что это значит? Может быть передано только строго 2 позиционных аргумента

Обобщаем в алгоритм:

1. Если способ вызова содержит *:
1.1. В сигнатуре функции тоже должна быть *, иначе не валидно
1.2. Если сигнатура содержит * И точки, значит количество точек в способе вызова должно быть не меньше числа точек в сигнатуре. Иначе возможна ситуация, что вызов не заполнит все слоты в сигнатуре. Для ошибок этого типа нужно отдельное сообщение об ошибке.

2. Если в способе вызова нет *:
2.1. Если в сигнатуре есть *: количество точек способа вызова должно быть БОЛЬШЕ ИЛИ равно количеству точек в сигнатуре
2.2. Если в сигнатуре нет *: количество точек способа вызова должно быть равно количеству точек в сигнатуре

# Именные аргументы

Дан способ вызова:

x, y, **

Что это значит? В вызове присутствуют аргументы x и y, а также какие угодно еще

Что отсюда следует?

1. В сигнатуре должно быть **
2. В сигнатуре НЕ должно быть обязательных именных параметров, кроме x, y (мы не можем быть уверены, что в ** будет передано все, что нужно)

Еще способ вызова:

**

Что это значит? В вызове могут присутствовать какие угодно аргументы

Что отсюда следует?

1. Сигнатура должна содержать **
2. Сигнатура не должна содержать никаких обязательных именных аргументов


Еще способ вызова:

x, y

Что это значит? Будут переданы 2 аргумента x и y

Что отсюда следует?

1. Если сигнатура не содержит **, в ней должны быть только 2 аргумента: x и y (не больше и не меньше)
2. Если сигнатура содержит **, в ней не должно быть других обязательных аргументов кроме x и y

Обобщаем:

3. Если способ вызова содержит **:
3.1. Сигнатура должна содержать **
3.2.1 Если в способе вызова есть именные аргументы, в сигнатуре НЕ должно быть других обязательных именных параметров, кроме перечисленных в способе вызова
3.2.2. Если в способе вызова нет именных аргументов, сигнатура не должна содержать никаких обязательных именных аргументов (обобщается с 3.2.1 как: любые обязательные именные аргументы сигнатуры должны содержаться в множестве тех, что перечислены в способе вызова)

4. Если в способе вызова нет **:
4.1. Если сигнатура не содержит **, именные аргументы сигнатуры и способа вызова должны строго совпадать (не больше и не меньше)
4.2. Если сигнатура содержит **, в ней не должно быть других обязательных аргументов кроме x и y

# Полный алгоритм

Объединяем алгоритмы матчинга именных и неименных аргументов.


1. Если способ вызова содержит *:
1.1. В сигнатуре функции тоже должна быть *, иначе не валидно
1.2. Если сигнатура содержит * И точки, значит количество точек в способе вызова должно быть не меньше числа точек в сигнатуре. Иначе возможна ситуация, что вызов не заполнит все слоты в сигнатуре. Для ошибок этого типа нужно отдельное сообщение об ошибке.

2. Если в способе вызова нет *:
2.1. Если в сигнатуре есть *: количество точек способа вызова должно быть БОЛЬШЕ ИЛИ равно количеству точек в сигнатуре
2.2. Если в сигнатуре нет *: количество точек способа вызова должно быть равно количеству точек в сигнатуре

3. Если способ вызова содержит **:
3.1. Сигнатура должна содержать **
3.2.1 Если в способе вызова есть именные аргументы, в сигнатуре НЕ должно быть других обязательных именных параметров, кроме перечисленных в способе вызова
3.2.2. Если в способе вызова нет именных аргументов, сигнатура не должна содержать никаких обязательных именных аргументов (обобщается с 3.2.1 как: любые обязательные именные аргументы сигнатуры должны содержаться в множестве тех, что перечислены в способе вызова)

4. Если в способе вызова нет **:
4.1. Если сигнатура не содержит **, именные аргументы сигнатуры и способа вызова должны строго совпадать (не больше и не меньше)
4.2. Если сигнатура содержит **, в ней не должно быть других обязательных аргументов кроме x и y


Система не ожидает ситуаций, что для позиционного аргумента используется имя (хотя так можно). Они рассматриваются изолированно.
"""
